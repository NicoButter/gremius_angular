// Backup of previous ActualidadComponent
// If anything goes wrong, use this file to restore previous logic.

/*
import { Component, ElementRef, ViewChild, AfterViewInit, HostListener } from '@angular/core';
import { NgIf } from '@angular/common';

@Component({
  selector: 'app-actualidad',
  standalone: true,
  imports: [NgIf],
  templateUrl: './actualidad.component.html',
  styleUrls: ['./actualidad.component.css']
})
export class ActualidadComponent implements AfterViewInit {
  plataforma: 'android' | 'ios' = 'android';
  modalActivo = false;
  imagenModal = '';
  tituloModal = '';
  textoModal = '';
  
  // Propiedades para el zoom y arrastre
  @ViewChild('contenedorRef') contenedorRef!: ElementRef;
  escala = 1;
  escalaMinima = 0.5;
  escalaMaxima = 3;
  offsetHorizontal = 0; // Solo para centrado horizontal
  offsetVertical = 0; // Para movimiento vertical
  arrastrando = false;
  puntoInicioY = 0; // Solo guardamos la posición Y inicial
  anchoImagenOriginal = 0;
  altoImagenOriginal = 0;
  anchoContenedor = 0;
  altoContenedor = 0;
  
  // Referencia para el indicador de zoom
  private zoomIndicator: HTMLElement | null = null;
  private timeoutZoomIndicator: any = null;

  cambiarPlataforma(plataforma: 'android' | 'ios') {
    this.plataforma = plataforma;
  }

  abrirModal(imagen: string, titulo: string, texto: string) {
    this.imagenModal = imagen;
    this.tituloModal = titulo;
    this.textoModal = texto;
    this.modalActivo = true;
    this.escala = 1;
    this.offsetHorizontal = 0;
    this.offsetVertical = 0;
    this.arrastrando = false;
    
    // Prevenir scroll del body cuando el modal está activo
    document.body.style.overflow = 'hidden';
    
    // Crear indicador de zoom si no existe
    this.crearIndicadorZoom();
    
    // Esperar un momento para calcular dimensiones
    setTimeout(() => {
      this.calcularDimensiones();
    }, 100);
  }

  cerrarModal(event: MouseEvent) {
    event.stopPropagation();
    this.modalActivo = false;
    // Restaurar scroll del body
    document.body.style.overflow = 'auto';
    
    // Ocultar indicador de zoom
    this.ocultarIndicadorZoom();
  }

  ngAfterViewInit() {
    // Agregar listener para tecla Escape
    document.addEventListener('keydown', this.escucharTeclaEscape.bind(this));
  }

  calcularDimensiones() {
    if (!this.contenedorRef || !this.modalActivo) return;
    
    const contenedor = this.contenedorRef.nativeElement;
    this.anchoContenedor = contenedor.offsetWidth;
    this.altoContenedor = contenedor.offsetHeight;
    
    // Centrar la imagen
    this.centrarImagen();
  }

  centrarImagen() {
    if (this.anchoImagenOriginal === 0 || this.altoImagenOriginal === 0) return;
    
    // Siempre mantener la imagen centrada horizontalmente
    this.offsetHorizontal = 0;
    
    // Verificar si la imagen es más pequeña que el contenedor verticalmente
    const altoImagenEscalada = this.altoImagenOriginal * this.escala;
    if (altoImagenEscalada < this.altoContenedor) {
      this.offsetVertical = 0;
    }
    // Si la imagen es más grande, mantenerla dentro de los límites
    else {
      const maxOffset = (altoImagenEscalada - this.altoContenedor) / 2;
      this.offsetVertical = Math.max(-maxOffset, Math.min(maxOffset, this.offsetVertical));
    }
  }

  manejarZoom(event: WheelEvent) {
    event.preventDefault();
    
    // Guardar posición vertical relativa antes del zoom
    const rect = event.currentTarget as HTMLElement;
    const mouseY = event.clientY - rect.getBoundingClientRect().top;
    
    // Calcular el centro vertical antes del zoom
    const centroY = this.altoContenedor / 2;
    
    // Determinar dirección del zoom
    const factorZoom = event.deltaY > 0 ? 0.9 : 1.1;
    const nuevaEscala = Math.min(Math.max(this.escala * factorZoom, this.escalaMinima), this.escalaMaxima);
    
    // Calcular nueva posición vertical para mantener el punto bajo el cursor
    if (this.altoImagenOriginal > 0) {
      const diferenciaEscala = nuevaEscala / this.escala;
      const offsetRelativo = mouseY - (this.altoContenedor / 2) - this.offsetVertical;
      this.offsetVertical = mouseY - (this.altoContenedor / 2) - (offsetRelativo * diferenciaEscala);
    }
    
    // Aplicar nueva escala
    this.escala = nuevaEscala;
    
    // Ajustar posición para mantener límites
    this.centrarImagen();
    
    // Mostrar indicador de zoom
    this.mostrarIndicadorZoom();
  }

  iniciarArrastre(event: MouseEvent) {
    // Solo permitir arrastre si la imagen está ampliada
    if (this.escala <= 1) {
      return;
    }
    
    this.arrastrando = true;
    this.puntoInicioY = event.clientY;
    event.preventDefault();
    
    // Cambiar cursor
    const contenedor = this.contenedorRef.nativeElement;
    contenedor.style.cursor = 'grabbing';
  }

  moverImagen(event: MouseEvent) {
    if (this.arrastrando && this.escala > 1) {
      const deltaY = event.clientY - this.puntoInicioY;
      
      this.offsetVertical += deltaY;
      
      this.puntoInicioY = event.clientY;
      
      // Aplicar límites para que la imagen no se salga del contenedor
      this.aplicarLimites();
    }
  }

  aplicarLimites() {
    if (this.altoImagenOriginal === 0) return;
    
    const altoImagenEscalada = this.altoImagenOriginal * this.escala;
    if (altoImagenEscalada > this.altoContenedor) {
      const maxOffset = (altoImagenEscalada - this.altoContenedor) / 2;
      this.offsetVertical = Math.max(-maxOffset, Math.min(maxOffset, this.offsetVertical));
    } else {
      // Si la imagen es más pequeña que el contenedor, mantenerla centrada
      this.offsetVertical = 0;
    }
  }

  finalizarArrastre() {
    this.arrastrando = false;
    
    // Restaurar cursor
    if (this.contenedorRef) {
      const contenedor = this.contenedorRef.nativeElement;
      contenedor.style.cursor = 'grab';
    }
  }

  crearIndicadorZoom() {
    // Eliminar indicador anterior si existe
    this.eliminarIndicadorZoom();
    
    // Crear nuevo indicador
    this.zoomIndicator = document.createElement('div');
    this.zoomIndicator.className = 'zoom-indicator';
    this.zoomIndicator.innerText = `Zoom: ${Math.round(this.escala * 100)}%`;
    document.querySelector('.modal-body')?.appendChild(this.zoomIndicator);
  }

  mostrarIndicadorZoom() {
    if (this.zoomIndicator) {
      this.zoomIndicator.innerText = `Zoom: ${Math.round(this.escala * 100)}%`;
      this.zoomIndicator.classList.add('visible');
      
      // Limpiar timeout anterior
      if (this.timeoutZoomIndicator) {
        clearTimeout(this.timeoutZoomIndicator);
      }
      
      // Ocultar después de 1 segundo de inactividad
      this.timeoutZoomIndicator = setTimeout(() => {
        this.ocultarIndicadorZoom();
      }, 1000);
    }
  }

The backup file content was successfully written.